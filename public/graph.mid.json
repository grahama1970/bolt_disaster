{
  "nodes": [
    { "_id": "sections/S1", "_key": "S1", "label": "Introduction to Formal Methods", "title": "Introduction to Formal Methods", "type": "section", "doc_id": "formal_methods_intro.pdf", "content": "This section introduces the fundamental concepts of formal methods in software verification, including model checking, theorem proving, and specification languages." },
    { "_id": "sections/S2", "_key": "S2", "label": "Lean4 Language Basics", "title": "Lean4 Language Basics", "type": "section", "doc_id": "lean4_guide.pdf", "content": "Comprehensive overview of Lean4 syntax, tactics, and basic proof techniques used in interactive theorem proving." },
    { "_id": "sections/S3", "_key": "S3", "label": "Dependent Type Theory", "title": "Dependent Type Theory Foundations", "type": "section", "doc_id": "type_theory.pdf", "content": "Mathematical foundations of dependent type systems, including the calculus of constructions and inductive types." },
    { "_id": "sections/S4", "_key": "S4", "label": "Proposition Logic", "title": "Propositional Logic in Lean4", "type": "section", "doc_id": "prop_logic.pdf", "content": "Basic propositional logic constructs and proof strategies in the Lean4 environment." },
    { "_id": "sections/S5", "_key": "S5", "label": "Predicate Logic", "title": "First-Order Predicate Logic", "type": "section", "doc_id": "pred_logic.pdf", "content": "First-order logic with quantifiers and their implementation in dependent type theory." },
    { "_id": "sections/S6", "_key": "S6", "label": "Inductive Definitions", "title": "Inductive Types and Definitions", "type": "section", "doc_id": "inductive_types.pdf", "content": "Construction and use of inductive types for defining data structures and properties." },
    { "_id": "sections/S7", "_key": "S7", "label": "Proof Tactics", "title": "Advanced Proof Tactics", "type": "section", "doc_id": "proof_tactics.pdf", "content": "Sophisticated proof automation and tactic programming in Lean4." },
    { "_id": "sections/S8", "_key": "S8", "label": "Program Verification", "title": "Software Verification Methods", "type": "section", "doc_id": "program_verification.pdf", "content": "Techniques for verifying correctness of imperative and functional programs." },
    { "_id": "sections/S9", "_key": "S9", "label": "Contradiction Analysis", "title": "Handling Logical Contradictions", "type": "section", "doc_id": "contradictions.pdf", "content": "Methods for detecting, analyzing, and resolving contradictions in formal proof systems." },
    { "_id": "sections/S10", "_key": "S10", "label": "Category Theory", "title": "Category Theory in Type Theory", "type": "section", "doc_id": "category_theory.pdf", "content": "Application of categorical concepts to dependent type theory and proof assistants." },
    { "_id": "lemmas/L1", "_key": "L1", "label": "Type Soundness", "title": "Type System Soundness Lemma", "type": "lemma", "doc_id": "soundness_proofs.pdf", "content": "Fundamental lemma proving that well-typed programs cannot get stuck during execution." },
    { "_id": "lemmas/L2", "_key": "L2", "label": "Proof Completeness", "title": "Proof System Completeness", "type": "lemma", "doc_id": "completeness_proofs.pdf", "content": "Every semantically valid statement has a syntactic proof in the formal system." },
    { "_id": "lemmas/L3", "_key": "L3", "label": "Logical Consistency", "title": "System Consistency Property", "type": "lemma", "doc_id": "consistency_proofs.pdf", "content": "The formal system cannot prove both a proposition and its negation simultaneously." },
    { "_id": "lemmas/L4", "_key": "L4", "label": "Contradiction Detection", "title": "Automated Contradiction Detection", "type": "lemma", "doc_id": "contradiction_detection.pdf", "content": "Algorithmic method for identifying contradictory assumptions in proof dependencies." },
    { "_id": "lemmas/L5", "_key": "L5", "label": "Induction Principle", "title": "Strong Induction Principle", "type": "lemma", "doc_id": "induction_principles.pdf", "content": "Well-foundedness implies the validity of strong induction over any well-founded relation." },
    { "_id": "lemmas/L6", "_key": "L6", "label": "Substitution Lemma", "title": "Type Substitution Preservation", "type": "lemma", "doc_id": "substitution_lemmas.pdf", "content": "Type judgments are preserved under well-typed substitutions." },
    { "_id": "lemmas/L7", "_key": "L7", "label": "Normalization", "title": "Strong Normalization Property", "type": "lemma", "doc_id": "normalization.pdf", "content": "All well-typed terms in the calculus terminate under beta-reduction." },
    { "_id": "lemmas/L8", "_key": "L8", "label": "Church-Rosser", "title": "Church-Rosser Property", "type": "lemma", "doc_id": "church_rosser.pdf", "content": "Beta-reduction satisfies the diamond property, ensuring confluence of reductions." },
    { "_id": "lemmas/L9", "_key": "L9", "label": "Decidability Lemma", "title": "Type Checking Decidability", "type": "lemma", "doc_id": "decidability_lemma.pdf", "content": "Type checking for the core calculus is decidable and terminates." },
    { "_id": "lemmas/L10", "_key": "L10", "label": "Subject Reduction", "title": "Subject Reduction Property", "type": "lemma", "doc_id": "subject_reduction.pdf", "content": "Types are preserved under evaluation in the operational semantics." },
    { "_id": "theorems/T1", "_key": "T1", "label": "Main Correctness", "title": "Complete System Correctness", "type": "theorem", "doc_id": "main_theorem.pdf", "content": "The complete formal proof system is both sound and complete for the intended semantics." },
    { "_id": "theorems/T2", "_key": "T2", "label": "Decidability Result", "title": "Type Checking Decidability Theorem", "type": "theorem", "doc_id": "decidability_theorem.pdf", "content": "Type checking is decidable for the full language subset we consider." },
    { "_id": "theorems/T3", "_key": "T3", "label": "Cut Elimination", "title": "Cut Elimination Theorem", "type": "theorem", "doc_id": "cut_elimination.pdf", "content": "Every proof in the sequent calculus can be transformed to a cut-free proof." },
    { "_id": "theorems/T4", "_key": "T4", "label": "Consistency Theorem", "title": "Global System Consistency", "type": "theorem", "doc_id": "consistency_theorem.pdf", "content": "The entire proof system with all axioms and rules is logically consistent." },
    { "_id": "theorems/T5", "_key": "T5", "label": "Extraction Correctness", "title": "Program Extraction Correctness", "type": "theorem", "doc_id": "extraction_correctness.pdf", "content": "Programs extracted from constructive proofs satisfy their specifications." },
    { "_id": "sections/S11", "_key": "S11", "label": "Advanced Topics", "title": "Advanced Lean4 Features", "type": "section", "doc_id": "advanced_features.pdf", "content": "Metaprogramming, tactic development, and advanced automation in Lean4." },
    { "_id": "sections/S12", "_key": "S12", "label": "Applications", "title": "Real-World Applications", "type": "section", "doc_id": "applications.pdf", "content": "Case studies of formal verification in industry and research settings." }
  ],
  "edges": [
    { "_id": "e1", "_from": "sections/S1", "_to": "sections/S2", "type": "depends_on", "weight": 0.85 },
    { "_id": "e2", "_from": "sections/S1", "_to": "sections/S4", "type": "depends_on", "weight": 0.75 },
    { "_id": "e3", "_from": "sections/S2", "_to": "sections/S3", "type": "depends_on", "weight": 0.9 },
    { "_id": "e4", "_from": "sections/S3", "_to": "sections/S6", "type": "depends_on", "weight": 0.8 },
    { "_id": "e5", "_from": "sections/S4", "_to": "sections/S5", "type": "depends_on", "weight": 0.88 },
    { "_id": "e6", "_from": "sections/S5", "_to": "lemmas/L1", "type": "depends_on", "weight": 0.92 },
    { "_id": "e7", "_from": "sections/S6", "_to": "lemmas/L5", "type": "depends_on", "weight": 0.87 },
    { "_id": "e8", "_from": "sections/S3", "_to": "lemmas/L6", "type": "depends_on", "weight": 0.85 },
    { "_id": "e9", "_from": "lemmas/L1", "_to": "lemmas/L10", "type": "refines", "weight": 0.9 },
    { "_id": "e10", "_from": "lemmas/L6", "_to": "lemmas/L7", "type": "refines", "weight": 0.82 },
    { "_id": "e11", "_from": "lemmas/L7", "_to": "lemmas/L8", "type": "refines", "weight": 0.88 },
    { "_id": "e12", "_from": "lemmas/L1", "_to": "theorems/T1", "type": "refines", "weight": 0.95 },
    { "_id": "e13", "_from": "lemmas/L2", "_to": "theorems/T1", "type": "refines", "weight": 0.93 },
    { "_id": "e14", "_from": "lemmas/L9", "_to": "theorems/T2", "type": "refines", "weight": 0.91 },
    { "_id": "e15", "_from": "lemmas/L8", "_to": "theorems/T3", "type": "refines", "weight": 0.89 },
    { "_id": "e16", "_from": "lemmas/L3", "_to": "theorems/T4", "type": "refines", "weight": 0.94 },
    { "_id": "e17", "_from": "sections/S7", "_to": "sections/S8", "type": "depends_on", "weight": 0.78 },
    { "_id": "e18", "_from": "sections/S8", "_to": "theorems/T5", "type": "depends_on", "weight": 0.86 },
    { "_id": "e19", "_from": "sections/S9", "_to": "lemmas/L4", "type": "depends_on", "weight": 0.92 },
    { "_id": "e20", "_from": "lemmas/L4", "_to": "lemmas/L3", "type": "contradicts", "weight": 0.65 },
    { "_id": "e21", "_from": "lemmas/L2", "_to": "lemmas/L3", "type": "contradicts", "weight": 0.58 },
    { "_id": "e22", "_from": "sections/S10", "_to": "sections/S11", "type": "depends_on", "weight": 0.72 },
    { "_id": "e23", "_from": "sections/S11", "_to": "sections/S12", "type": "depends_on", "weight": 0.68 },
    { "_id": "e24", "_from": "theorems/T1", "_to": "theorems/T4", "type": "knn", "weight": 0.82 },
    { "_id": "e25", "_from": "theorems/T2", "_to": "theorems/T3", "type": "knn", "weight": 0.75 },
    { "_id": "e26", "_from": "lemmas/L1", "_to": "lemmas/L10", "type": "knn", "weight": 0.88 },
    { "_id": "e27", "_from": "lemmas/L7", "_to": "lemmas/L8", "type": "knn", "weight": 0.91 },
    { "_id": "e28", "_from": "sections/S3", "_to": "sections/S6", "type": "knn", "weight": 0.79 },
    { "_id": "e29", "_from": "sections/S4", "_to": "sections/S5", "type": "knn", "weight": 0.84 },
    { "_id": "e30", "_from": "sections/S7", "_to": "sections/S11", "type": "knn", "weight": 0.73 }
  ]
}